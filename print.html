<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>dialectic</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">Introduction</a></li><li class="chapter-item expanded "><a href="technical_overview.html"><strong aria-hidden="true">1.</strong> Technical overview</a></li><li class="chapter-item expanded "><a href="analysis_preconditions.html"><strong aria-hidden="true">2.</strong> Analysis preconditions</a></li><li class="chapter-item expanded "><a href="behavioral_definitions.html"><strong aria-hidden="true">3.</strong> Behavioral definitions</a></li><li class="chapter-item expanded "><a href="construct_bom.html"><strong aria-hidden="true">4.</strong> Constructing a BOM</a></li><li class="chapter-item expanded "><a href="generating_a_netlist.html"><strong aria-hidden="true">5.</strong> Generating a netlist</a></li><li class="chapter-item expanded "><a href="place_and_route.html"><strong aria-hidden="true">6.</strong> Automatic place and route</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">dialectic</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="dialectic"><a class="header" href="#dialectic">Dialectic</a></h1>
<p><a href="https://github.com/silvergasp/dialectic/discussions">Discussions</a></p>
<h2 id="about"><a class="header" href="#about">About</a></h2>
<p>Dialectic is an <em>early-stage</em> project to create a modern alternative to
graphical PCB designs. This is a code-first approach to PCB design. Some of the
approaches taken in dialectic may be somewhat controversial.</p>
<p>Why dialectic? The name came from an intentional play of words between similar
sounding terms dielectric (meaning conductive insulator) and dialectic (meaning
discourse around apposing views).</p>
<p>Dialectic draws inspiration from existing hardware description languages
including;</p>
<ul>
<li>Verilog</li>
<li>VHDL</li>
<li>Chisel</li>
<li>XLS</li>
</ul>
<p>And circuit description languages including;</p>
<ul>
<li>pycircuit</li>
<li>skidl</li>
</ul>
<p>Dialectic differs from the above in that it is intended to address areas areas
that digital logic HDL's don't. e.g.</p>
<ul>
<li>Analog signals and circuits.</li>
<li>Power distribution.</li>
<li>Firmware integration.</li>
<li>BOM generation and optimization.</li>
<li>PCB Automatic placement and routing.</li>
</ul>
<h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<p>Currently as dialectic is in the planning phase. To contribute just jump on the
<a href="https://github.com/silvergasp/dialectic/discussions">discussions tab</a>. At this
point all input is welcome e.g.</p>
<ul>
<li>Feature requests.</li>
<li>Suggestions.</li>
<li>Requests for consultation (Use issues tab for this).</li>
</ul>
<h2 id="sponsors"><a class="header" href="#sponsors">Sponsors</a></h2>
<p>Dialectic currently does not have any sponsors ðŸ˜”. Please consider sponsoring
this project to help make dialectic sustainable long-term.</p>
<h2 id="status"><a class="header" href="#status">Status</a></h2>
<p>Currently dialectic is in the planning phase and minimal or no implementation
exists for.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="technical-overview"><a class="header" href="#technical-overview">Technical overview</a></h1>
<p>The high level design for the dialectic HDL follows a similar
approach to what a team of engineers would follow. In this case
dialectic will implement this as a pipelined series of grouped passes.</p>
<blockquote>
<p>Note: This approach is largely inspired by the <a href="https://circt.llvm.org/">CIRCT</a> project. With which
this project
may integrate with as an additional dialect at some point.</p>
</blockquote>
<p>Passes are grouped logically to ensure that each pass can operate on similar
data. For example consider the below group of passes.</p>
<pre><code class="language-mermaid">graph TB
A[Define Environmental Constraints] --&gt; C;
B[Define Manufacturing Constraints] --&gt; C;
C[Finalize BOM and manufacturing constraints]
</code></pre>
<p>First we constrain the environmental conditions that the end product needs to
operate in for example this may look something like;</p>
<pre><code class="language-rust ignore">let environment = dialectic::environment()
                    .temperature_range(-10.0,60.0)
                    .humidity_range(0.0, 80.0)
                    .pressure_range(500.mbar(), 1500.mbar());

// Manufacturing constraints from PCBway
let pcb_constraints = dialectic::pcb_manufacturing()
                    .stackup(
                        dialectic::Stackup::new(vec![
                            Material::Silkscreen(None),
                            Material::Soldermask(None),
                            Material::Copper(35.um()),
                            Material::Prepreg(0.11.mm(), 4.29.rel_permeability()),
                            // ...
                        ])
                    )
                    .width_range(5.0, 500.0)
                    .height_range(6.0, 1100.0)
                    .min_trace(0.1)
                    .min_spacing(0.1);
                    // more constraints... ;

let assembly_constraints = dialectic::assembly()
                    .components_on_top()
                    .components_on_bottom()
                    .max_reflow_temperature(270.0);
                    // more constrains... ;

let preconditions = dialectic::Preconditions::new(
    environment,
    pcb_constraints,
    assembly_constraints,
)
</code></pre>
<blockquote>
<p>Note: For the time being we will be using Rust as a generator language. But
this may change depending on requirements.</p>
</blockquote>
<p>By setting these preconditions we can;</p>
<ul>
<li>Build a set of filters from component selection based on;
<ul>
<li>Component size.</li>
<li>Spacing between pads on footprints.</li>
<li>Operational environment.</li>
<li>etc.</li>
</ul>
</li>
<li>Define a set of constraints for placement and routing.</li>
</ul>
<h2 id="high-level-pipeline"><a class="header" href="#high-level-pipeline">High level pipeline</a></h2>
<p>While the first example show how a group of design passes <strong>might</strong> work it
doesn't give a full overview of what the entire system will look like.</p>
<pre><code class="language-mermaid">graph TB
A[Analysis Preconditions] --&gt; C;
B[Behavioral definitions] --&gt; C;
C[Construct BOM] --&gt; D;
D[Generate netlist] --&gt; E;
D --&gt;|Failure| C;
E[Automatically place and route] --&gt;|Success| F;
E --&gt;|Failure| C;
F[Generate manufacturing files]
</code></pre>
<p>To the untrained eye this system may seem like a simple one to put together.
However there are some very challenging and difficult problems to solve.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="analysis-preconditions"><a class="header" href="#analysis-preconditions">Analysis preconditions</a></h1>
<blockquote>
<p>Note: This section is incomplete.</p>
</blockquote>
<p>This stage in the pipeline is used to constrain your design e.g.</p>
<ul>
<li>The operating temperature, pressure, humidity ranges.</li>
<li>The PCB manufacturing process.</li>
<li>The PCB assembly process.</li>
</ul>
<p>This stage isn't intended to do anything particularly fancy. Instead it is just
a means of collecting data to constrain the design at later stages in the
pipeline.</p>
<h2 id="operating-environment"><a class="header" href="#operating-environment">Operating environment</a></h2>
<p>The following set of constraints are proposed to optionally constrain the design of your device;</p>
<ul>
<li>Temperature range.</li>
<li>Pressure range.</li>
<li>Vibration.</li>
<li>Humidity.</li>
<li>Heat dissipation.</li>
</ul>
<h2 id="pcb-manufacturing"><a class="header" href="#pcb-manufacturing">PCB Manufacturing</a></h2>
<p>The following set of constraints are proposed to optionally constrain the design of your device;</p>
<h3 id="vias"><a class="header" href="#vias">Vias</a></h3>
<ul>
<li>Minimum width annular ring.</li>
<li>Drill sizes (list)</li>
<li>Microvias</li>
<li>Blind vias</li>
<li>Buried vias</li>
<li>Plug hole diameter</li>
</ul>
<h3 id="clearance"><a class="header" href="#clearance">Clearance</a></h3>
<ul>
<li>Minimum trace width</li>
<li>Hole to hole clearance</li>
</ul>
<h3 id="stackup"><a class="header" href="#stackup">Stackup</a></h3>
<ul>
<li>List of material variants
<ul>
<li>Fiberglass (FR4)</li>
<li>Copper</li>
<li>Prepreg</li>
<li>Solder-mask</li>
<li>etc.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="behavioral-definitions"><a class="header" href="#behavioral-definitions">Behavioral definitions</a></h1>
<blockquote>
<p>Note: This section is incomplete.</p>
</blockquote>
<p>Functionally when we use a circuit we don't care how that circuit
is implemented. Nor do we care how it functions. We care how it behaves and what
value it adds to our lives.</p>
<p>So if we care about how a circuit adds value to our lives would it not make
sense to start at a high level of abstraction and just say hey. What do I want
my circuit to be able to do?</p>
<p>Consider an example of a fitness tracker that counts your steps and displays
that on a screen. But does nothing else.</p>
<p>If we break this behavior down into it's components we get a;</p>
<ul>
<li>Sensor to detect a step,</li>
<li>Computation system to interpret sensor output,</li>
<li>Counter to keep track of steps,</li>
<li>Display to show us the steps,</li>
</ul>
<p>TODO: Add a code example here defining custom constraints.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constructing-a-bom"><a class="header" href="#constructing-a-bom">Constructing a BOM</a></h1>
<p>Now that we have defined our operational and manufacturing constraints. We can
start selecting components. At a high level this process would follow the
following approach.</p>
<ul>
<li>Pre-filtering based on manufacturing and operating constraints.</li>
<li>For each behavior find a set of components/predefined sub-circuits that meet
your needs. Narrow to single instantiate based on some heuristic.</li>
<li>Each of the narrowed components/sub-circuits have their own constraints. These
constraints should be handled recursively.</li>
<li>An end state for BOM generation is met when each recursive component has it's
requirements met.</li>
<li>Optionally create a set cost reduction passes. For example while the first
set of 'seed' components might have been chosen to be the cheapest, the sum of
their supporting parts (i.e. recursively chosen) parts maybe more expensive.</li>
</ul>
<p>This type of process predicates on having highly detailed;</p>
<ul>
<li>Footprints,</li>
<li>Component descriptions (aka schematic libraries),</li>
<li>Predefined functional sub-circuits.</li>
</ul>
<blockquote>
<p>Note: While automation is great, sometimes for very specific reasons you want
to choose a very specific part. It is the intention that it be possible to
manually override each stage/pass in this process.</p>
</blockquote>
<h2 id="pre-filtering"><a class="header" href="#pre-filtering">Pre-filtering</a></h2>
<p>Pre-filter parts database based on manufacturing and operating constraints. e.g.
The following database of resistors with the following pre-filter;</p>
<ul>
<li>Min temp: -20</li>
<li>Min copper spacing: 0.65mm</li>
</ul>
<table><thead><tr><th>Value</th><th>Min temp</th><th>Package</th></tr></thead><tbody>
<tr><td>10k</td><td>-5</td><td>0402</td></tr>
<tr><td>10k</td><td>-10</td><td>0805</td></tr>
<tr><td>10k</td><td>-40</td><td>0805</td></tr>
<tr><td>11k</td><td>-40</td><td>0805</td></tr>
</tbody></table>
<p>Would be reduced to;</p>
<table><thead><tr><th>Value</th><th>Min temp</th><th>Package</th></tr></thead><tbody>
<tr><td>10k</td><td>-40</td><td>0805</td></tr>
<tr><td>11k</td><td>-40</td><td>0805</td></tr>
</tbody></table>
<h2 id="behavior-matching"><a class="header" href="#behavior-matching">Behavior matching</a></h2>
<p>For each behavior search through your database of parts/predefined sub-circuits
and find a set of 'candidate' components that meet your requirements. This may
involve guiding this process of behavior down to function. e.g.</p>
<p>Using a some guiding heuristic (e.g. minimize component cost), choose a single
component/sub-circuit that meets the behavior. In some cases this can be
specialized down to a physical interface e.g.</p>
<p>A resistor with the follow constraints;</p>
<ul>
<li>Value: 10k</li>
<li>Min temperature: -20</li>
<li>Package: 0402</li>
</ul>
<p>It is not necessary to specialize down to a particular part number at this point
as there are multiple parts that can meet the 0402 physical interface. This
can only be done on parts that have the same physical footprint/interface.</p>
<p>These first set of matching components are considered 'Seeds' for the rest of
the schematic, on which the schematic will naturally grow.</p>
<h2 id="recursive-behavior-matching"><a class="header" href="#recursive-behavior-matching">Recursive behavior matching</a></h2>
<p>As previously mentioned the 'seed' components have their own set of constraints
and requirements. e.g. An accelerometer sensor chosen in the previous step may
need 1.8-3.3V to operate, therefore the next stage of the recursive matching
might involve a buck converter and/or a battery.</p>
<h2 id="bom-optimization-optional"><a class="header" href="#bom-optimization-optional">BOM optimization (Optional)</a></h2>
<p>There are many opportunities for BOM cost reduction. While each recursive stage
might be optimized for cost. This involves a greedy and non-optimal search
pattern. There are also multiple areas where constraints can be reduced to allow
for a greater range of freedom in BOM reduction. e.g. Consider 3 parts A, B and
C currently candidates for the BOM.</p>
<p><em>Part A has 2 pins</em></p>
<ul>
<li>GND</li>
<li>VDD
<ul>
<li>Requires 1.8-3.3V @ up to 50mA</li>
<li>Requires 80-200nF of capacitance for decoupling</li>
</ul>
</li>
</ul>
<p><em>Part B has 2 pins</em></p>
<ul>
<li>GND</li>
<li>VDD
<ul>
<li>Requires 3.0-3.3V @ up to 800mA</li>
<li>Requires 90-150nF of capacitance for decoupling</li>
</ul>
</li>
</ul>
<p><em>Part C has 2 pins</em></p>
<ul>
<li>GND</li>
<li>VDD
<ul>
<li>Requires 1.8-2.5V @ up to 5mA</li>
<li>Requires 90-150nF of capacitance for decoupling</li>
</ul>
</li>
</ul>
<p>It's fairly reasonable to assume that;</p>
<ul>
<li>A &amp; C can share a power rail.</li>
<li>A &amp; B can share a power rail.</li>
<li>B &amp; C cannot share a power rail.</li>
</ul>
<p>So at least two power rails will be required. However all three have a range of
capacitances that overlap such that an acceptable capacitor can be chosen for
all three reducing the unique component count. e.g. a 100nF capacitor with a 10%
tolerance will work for all three.</p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<blockquote>
<p>Note: This example has some known issue;</p>
<ul>
<li>Doesn't address logic levels in database search.</li>
<li>Doesn't address multi-purpose pin-remapping and conflicts.</li>
<li>Doesn't address the relationship between cpu-&gt;spi_peripheral.</li>
<li>Doesn't address the relationship between firmware size and flash storage.</li>
<li>SPI bus is shared between accelerometer and display. But the count for GPIO
chip selects isn't checked.</li>
<li>Doesn't include scenarios showing when multiple components match a given
requirement.</li>
</ul>
<p>There is a bit of a balance between writing a concise example and missing
critical details. This is also a WIP and I haven't worked out all the details
yet. If you think that I've missed something important please feel free to
<a href="https://github.com/silvergasp/dialectic/issues/new/choose">open an issue</a>.
If you think that you could improve this example feel free to contact me
under the
<a href="https://github.com/silvergasp/dialectic/discussions">discussions tab</a>.</p>
</blockquote>
<p>Let's go back to our step counter, and see how this recursive component
selection might work on a simplified database of parts.</p>
<p>So let's say we start with a 'sensor to detect a step'. First we would need to
map this requirement to a physical phenomenon that can be measured. So when we
take a step with accelerate slightly forward and then accelerate slightly
backwards as our foot impacts the ground again. Not only that but we will likely
do a little bob vertically as well. So a sensor that can measure acceleration
with some post processing can count steps! Now it's likely that we will want to
constrain this further. For example we don't want a sensor that can only sample
once a second as we wouldn't be able to determine how many steps you take unless
you take less than 0.5 steps/s. So the world record for 'skips'/seconds is 9.6
skips/s. This is roughly the same motion as a step so let's use that as our
baseline. At that rate we would need at minimum 19.2Hz to prevent aliasing. But
it's likely that we would want significantly more. So let's go with 4x9.6=38.4Hz
as a minimum sampling rate.</p>
<blockquote>
<p>NOTE: there might be other was of doing this at a
later time e.g. using a ranging sensor that measures distance to the ground. So
it's still useful to keep the original abstract concept of a step counter.</p>
</blockquote>
<pre><code class="language-mermaid">graph TB
A[Sensor to detect a step]
B[Computation system to interpret sensor output]
C[Counter to keep track of steps]
D[Display to show us the step count]
style A fill:#f9f
style B fill:#f9f
style C fill:#f9f
style D fill:#f9f
</code></pre>
<p>So this is where we can start searching for a part in our database. To simplify
this example I've only put one sensor that will work. So find the 'Accelerometer'
sensor. So we find the part 'Accel101' that matches our sampling requirements.</p>
<pre><code class="language-mermaid">graph BT
A[Sensor to detect a step]
B[Computation system to interpret sensor output]
C[Counter to keep track of steps]
D[Display to show us the step count]
E[Accel101]--&gt;|provides|A
</code></pre>
<p>Now we find that 'Accel101' has requirements on it's own. Specifically it needs
power and an SPI controller. So we search for a power provider that will work
for our accelerometer and we find a battery.</p>
<pre><code class="language-mermaid">graph BT
A[Sensor to detect a step]
B[Computation system to interpret sensor output]
C[Counter to keep track of steps]
D[Display to show us the step count]
style A fill:#f9f
style B fill:#f9f
style C fill:#f9f
style D fill:#f9f

E[Accel101]--&gt;|provides acceleration|A
F[Battery]--&gt;|provides power|E
</code></pre>
<p>We then search for a device that can act as a SPI controller and find the
'ControlFreak1000' micro-controller.</p>
<pre><code class="language-mermaid">graph BT
A[Sensor to detect a step]
B[Computation system to interpret sensor output]
C[Counter to keep track of steps]
D[Display to show us the step count]
style A fill:#f9f
style B fill:#f9f
style C fill:#f9f
style D fill:#f9f

E[Accel101]--&gt;|provides acceleration|A
F[Battery]--&gt;|provides power|E
G[ControlFreak1000]--&gt;|provides SPI controller|E
</code></pre>
<p>The control freak micro-controller also by coincidence happens to provide
functionality for two more of our behavioral definitions via it's cpu;</p>
<ul>
<li>Computation system to interpret sensor output,</li>
<li>Counter to keep track of steps.</li>
</ul>
<pre><code class="language-mermaid">graph BT
A[Sensor to detect a step]
B[Computation system to interpret sensor output]
C[Counter to keep track of steps]
D[Display to show us the step count]
style A fill:#f9f
style B fill:#f9f
style C fill:#f9f
style D fill:#f9f

E[Accel101] --&gt; |provides acceleration| A
F[Battery] --&gt; |provides power| E
G[ControlFreak1000] --&gt; |provides SPI controller|E
G --&gt; |Provides computation| B
G --&gt; |Provides counter| C
</code></pre>
<p>The micro-controller however has a it's own requirements. Again we have to solve
the power problem. However as we've already chosen the battery, and the voltage
should work we just have to check that the battery can provide enough power for
both the accelerometer and the micro-controller at the same time. 0.1 + 0.01 &lt; 1
so we can keep the battery in our proposed BOM.</p>
<pre><code class="language-mermaid">graph BT
A[Sensor to detect a step]
B[Computation system to interpret sensor output]
C[Counter to keep track of steps]
D[Display to show us the step count]
style A fill:#f9f
style B fill:#f9f
style C fill:#f9f
style D fill:#f9f

E[Accel101] --&gt; |provides acceleration| A
F[Battery] --&gt; |provides power| E
G[ControlFreak1000] --&gt; |provides SPI controller|E
F[Battery] --&gt; |provides power| G
G --&gt; |Provides computation| B
G --&gt; |Provides counter| C
</code></pre>
<p>We have one final behavior that we need to meet 'Display to show us the step
count', So we search through our database and find our 'Display100' part. Again
the display requires some power, we check our current BOM to see if we have
anything that can provide that. We find the battery, we just need to check that
the battery can supply power to the micro-controller, accelerometer and display
all at once. It can so we at this point we have an automatically generated BOM,
that meets our needs.</p>
<pre><code class="language-mermaid">graph BT
A[Sensor to detect a step]
B[Computation system to interpret sensor output]
C[Counter to keep track of steps]
D[Display to show us the step count]
style A fill:#f9f
style B fill:#f9f
style C fill:#f9f
style D fill:#f9f

E[Accel101] --&gt; |provides acceleration| A
F[Battery] --&gt; |provides power| E
G[ControlFreak1000] --&gt; |provides SPI controller|E
F[Battery] --&gt; |provides power| G
G --&gt; |Provides computation| B
G --&gt; |Provides counter| C
H[Display] --&gt; |Provides display|D
G[ControlFreak1000] --&gt; |provides SPI controller|H
</code></pre>
<h3 id="database"><a class="header" href="#database">Database</a></h3>
<p><em>Part: ControlFreak1000</em></p>
<ul>
<li>cpu: Cortex-M0</li>
<li>Spi: Provides controller
<ul>
<li>Count: 1</li>
</ul>
</li>
<li>GPIO: Provides in or output
<ul>
<li>Count: 4</li>
</ul>
</li>
<li>Power: Requires 1.8-3.3V @ up to 100mA
<ul>
<li>Decoupling:
<ul>
<li>Count: 4</li>
<li>Value: 100-200nF</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><em>Part: Cap1</em></p>
<ul>
<li>value: 1uF,</li>
<li>tolerance: 10%,</li>
</ul>
<p><em>Part: Cap3</em></p>
<ul>
<li>value: 120nF,</li>
<li>tolerance: 10%,</li>
</ul>
<p><em>Part: Accel101</em></p>
<ul>
<li>Acceleration: Provides 1-10G 24bit 200Hz sampling rate</li>
<li>Spi: Requires controller</li>
<li>CS: Requires GPIO</li>
<li>Power: Requires 1.8-3.3V @ up to 10mA
<ul>
<li>Decoupling:
<ul>
<li>Count: 1</li>
<li>Value: 50-150nF</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><em>Part: Battery</em></p>
<ul>
<li>Provides 1.8-2.2V @ up to 1A</li>
</ul>
<p><em>Part: Display100</em></p>
<ul>
<li>Display: Provides display</li>
<li>Power: Requires 1.8-5.0V @ up to 100mA
<ul>
<li>Decoupling:
<ul>
<li>Count: 1</li>
<li>Value: 0.5-10uF</li>
</ul>
</li>
</ul>
</li>
<li>Spi: Requires controller</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generating-a-netlist"><a class="header" href="#generating-a-netlist">Generating a netlist</a></h1>
<blockquote>
<p>Note: This description is still a work in progress.</p>
</blockquote>
<p>The process for generating a net-list for a design is not dissimilar to the
process of generating the BOM.</p>
<p>We take each constraint in the BOM and match abstract concepts against physical
interfaces. In the previous example of a step counter we had an accelerometer
that interfaced with a microcontroller via SPI. In many cases it's useful to
defer a concrete net-list to the routing stage. Instead of saying that PinA1 is
going to be SPI1-Clock and then routing as is, we can say that the
accelerometer uses one of the SPI interfaces provided by the microcontroller and
allow the routing algorithm to pin-swap to optimize the circuit.</p>
<blockquote>
<p>Note: There is of course a problem with this approach and that is each pin has
a finite set alternative functions, and even if a micro-controller provides 4
SPI interfaces it might not be possible to use all of them if other GPIO pins
are also being used. This seems like a solvable problem, but as it currently
stands an algorithm to solve this hasn't been developed for dialectic.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="automatic-place-and-route"><a class="header" href="#automatic-place-and-route">Automatic place and route</a></h1>
<blockquote>
<p>If you think that you could improve or feel like I've missed something
important this page feel free to contact me under the
<a href="https://github.com/silvergasp/dialectic/discussions">discussions tab</a>. Though
keep in mind that this description is far from complete.</p>
</blockquote>
<p>It's worth pointing out that the PCB layout community is understandably jaded
when it comes to auto-routing/placement. This comes from a long history of
sub-par auto-routers. I personally have used commercial auto-routers and had
them absolutely butcher my layout, ripping up more traces than it routed. So I
am approaching this problem with equal parts optimism and deep shades of jade.</p>
<p>Auto-routing is hard! A quick read over the
<a href="https://en.wikipedia.org/wiki/Routing_(electronic_design_automation)">Wikipedia page</a>
describing auto-routing and you'll see phrases like;</p>
<blockquote>
<p>&quot;Almost every problem associated with routing is known to be intractable.&quot;</p>
</blockquote>
<p>However the fact that these problems are 'intractable' is no excuse for poor
performance from an auto-router. After all we are able to route circuits
manually, usually with 'better' results.</p>
<p>So if we can manually route a circuit there is no reason why we can't develope
an algorithm to do the same thing automatically. After all we didn't evolve
to layout circuits so we don't have some fundamental evolutionary advantage that
we developed over 10,000s of years that a CPU does not.</p>
<p>So why don't auto-routers perform up to our expectations? I don't have all the
answers, but I have a set of hunches (which are open challenge).</p>
<ol>
<li>Auto-routers don't have the same level of control as what we do. e.g. usually
they can't pin-swap, they can't move parts around (e.g. to make more space
for vias or length matching). They can't completely change package if a
different footprint would work better.</li>
<li>We are biased to prefer manually routed circuits. In some cases auto-routers
<em>may</em> be performing as good as our hand routed designs but we just don't
recognize that because we are trained to like our circuits routed in a
particular way.</li>
<li>Typically engineers will route a PCB using 'rules of thumb', which are
<strong>usually</strong> simplifications of more complex physics. Often search algorithms
(i.e. auto-routers) will quickly find edge cases and loop holes in simplified
rules. Therefore we should give auto-routers more information as to the
underlying physics associated with electronics.</li>
<li>We don't give auto-routers enough information about what we want our routing
to look like. Without a suitable set of constraints we can't expect an
auto-router to route a decent circuit. In other words garbage in garbage out.</li>
</ol>
<h2 id="proposed-solution-for-dialectic-auto-routing"><a class="header" href="#proposed-solution-for-dialectic-auto-routing">Proposed solution for dialectic auto-routing</a></h2>
<p>The current proposal for auto-routing is to use a multi-stage iterative approach.
giving the auto-router full controllability over the design process. So simplified
pipeline would look something like the following.</p>
<pre><code class="language-mermaid">graph TB
S[Start] --&gt; A
style S fill:#f9f
A[Auto-place parts] --&gt; B
subgraph Attempt place and route N times
B[Auto-route] --&gt; |Failure| C
C[Slightly move parts] --&gt; B
end
B --&gt; |Failure| E
E[Modify part variants] --&gt; A
B --&gt; |Success| D
D[Done]
</code></pre>
<h3 id="routing-algorithm"><a class="header" href="#routing-algorithm">Routing algorithm</a></h3>
<p>Routing algorithms started off fairly simple. With the first auto-router using
Lee's maze solving algorithm. Which is essentially a grid based breadth first
search with backtracking. Today most high end auto-routers use an algorithm
based on topological auto-routing which tends to work better for high-density
circuits.</p>
<h4 id="potential-improvements-on-topological-routing"><a class="header" href="#potential-improvements-on-topological-routing">Potential improvements on topological-routing</a></h4>
<p>There are a couple of improvements that can be made to typical auto-routers;</p>
<ol>
<li>Return path routing</li>
</ol>
<h5 id="return-path-routing"><a class="header" href="#return-path-routing">Return path routing</a></h5>
<p>Currently (at least in the auto-routers I've used) there is very little effort
put into routing/managing the signal return path. What I'd like to propose is
that each signal be treated as a set of two links (see
<a href="https://en.wikipedia.org/wiki/Link_(knot_theory)">topological link/knot theory</a>). At least
one of the two links with either a ground <strong>or</strong> power return path must be
routed into the board. By simultaneously routing both the signal and return path
you can minimize EMI and reduce signal integrity. While a power and/or ground
planes may still be used it will still likely be useful to keep track of your
routed return paths through those planes as intersections on the return path
routing may result in increased current density.</p>
<pre><code class="language-mermaid">graph LR

A[Pin 1] --&gt;|Signal| B[Pin 2]
B --&gt;|Vdd return path| A
B --&gt;|GND return path| A
</code></pre>
<p>This approach has the most potential when routing 1-2 layer boards. For example
a ground trace can be routed parallel to signal traces to minimize EMI and
maximize signal integrity.</p>
<p>There is also significant gains to be made in very high speed designs, where
signal integrity and EMI are much more difficult to manage.</p>
<h2 id="other-constraints"><a class="header" href="#other-constraints">Other constraints</a></h2>
<p>In many cases there will be other constraints that need to be met for the circuit
to work as part of a larger electromechanical design e.g. connector locations
PCB shape etc. How these constraints are applied is yet to be determined.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
                <script type="text/javascript" src="mermaid.min.js"></script>
                <script type="text/javascript" src="mermaid-init.js"></script>
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
